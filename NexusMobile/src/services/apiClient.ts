import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios'; import AsyncStorage from '@react-native-async-storage/async-storage'; import { Platform } from 'react-native'; import { offlineManager } from './offlineManager'; class ApiClient { private client: AxiosInstance; private baseURL: string; constructor() { this.baseURL = Platform.select({ ios: 'http: android: 'http: web: 'http: default: 'http: }) || 'http: this.client = axios.create({ baseURL: this.baseURL, timeout: 10000, headers: { 'Content-Type': 'application/json', 'Accept': 'application/json', }, }); this.setupInterceptors(); this.initializeSync(); } private async setupInterceptors() { this.client.interceptors.request.use( async (config: AxiosRequestConfig) => { try { const token = await AsyncStorage.getItem('nexus-auth-token'); if (token && config.headers) { config.headers.Authorization = `Bearer ${token}`; } } catch (error) { console.error('Error getting auth token:', error); } return config; }, (error) => Promise.reject(error) ); this.client.interceptors.response.use( (response: AxiosResponse) => response, async (error) => { if (error.response?.status === 401) { await AsyncStorage.removeItem('nexus-auth-token'); } return Promise.reject(error); } ); } async login(email: string, password: string) { const response = await this.client.post('/api/auth/login', { email, password }); const { token } = response.data; await AsyncStorage.setItem('nexus-auth-token', token); return response.data; } async register(userData: { email: string; password: string; firstName: string; lastName: string }) { const response = await this.client.post('/api/auth/register', userData); return response.data; } async logout() { await AsyncStorage.removeItem('nexus-auth-token'); } async getFinancialMetrics(startDate?: string, endDate?: string) { const cacheKey = `financial-metrics-${startDate || 'all'}-${endDate || 'all'}`; return offlineManager.apiCallWithOffline( async () => { const params = startDate && endDate ? { start_date: startDate, end_date: endDate } : {}; const response = await this.client.get('/api/analytics/financial-metrics', { params }); return response.data; }, cacheKey ); } async getTransactions(startDate?: string, endDate?: string, limit = 100) { const cacheKey = `transactions-${startDate || 'all'}-${endDate || 'all'}-${limit}`; return offlineManager.apiCallWithOffline( async () => { const params = { start_date: startDate, end_date: endDate, limit }; const response = await this.client.get('/api/analytics/transactions', { params }); return response.data; }, cacheKey ); } async getTrendData(period = '30d') { const cacheKey = `trend-data-${period}`; return offlineManager.apiCallWithOffline( async () => { const response = await this.client.get('/api/analytics/trends', { params: { period } }); return response.data; }, cacheKey ); } async getRiskMetrics() { const cacheKey = 'risk-metrics'; return offlineManager.apiCallWithOffline( async () => { const response = await this.client.get('/api/analytics/risk-metrics'); return response.data; }, cacheKey ); } async getPredictiveInsights() { const cacheKey = 'predictive-insights'; return offlineManager.apiCallWithOffline( async () => { const response = await this.client.get('/api/analytics/predictive-insights'); return response.data; }, cacheKey ); } async get(url: string, config?: AxiosRequestConfig) { return this.client.get(url, config); } async post(url: string, data?: any, config?: AxiosRequestConfig) { return this.client.post(url, data, config); } async put(url: string, data?: any, config?: AxiosRequestConfig) { return this.client.put(url, data, config); } async delete(url: string, config?: AxiosRequestConfig) { return this.client.delete(url, config); } async isAuthenticated(): Promise<boolean> { try { const token = await AsyncStorage.getItem('nexus-auth-token'); return !!token; } catch { return false; } } getBaseURL(): string { return this.baseURL; } private initializeSync() { setInterval(async () => { await offlineManager.processSyncQueue(); }, 5 * 60 * 1000); } async syncData(): Promise<void> { await offlineManager.processSyncQueue(); } async getOfflineStatus() { const isOnline = await offlineManager.isOnline(); const cacheInfo = await offlineManager.getCacheInfo(); const syncQueue = await offlineManager.getSyncQueue(); return { isOnline, cacheSize: cacheInfo.size, pendingSyncItems: syncQueue.length, }; } } export const apiClient = new ApiClient(); export default apiClient;
