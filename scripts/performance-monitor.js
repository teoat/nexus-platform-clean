#!/usr/bin/env node /** * NEXUS Platform - Performance Monitor * Monitors agent performance, job completion rates, and system metrics */ const express = require('express'); const WebSocket = require('ws'); const http = require('http'); const cors = require('cors'); class PerformanceMonitor { constructor() { this.metrics = new Map(); this.agentPerformance = new Map(); this.jobMetrics = new Map(); this.systemMetrics = { totalJobs: 0, completedJobs: 0, failedJobs: 0, averageCompletionTime: 0, systemUptime: Date.now() }; this.app = express(); this.server = http.createServer(this.app); this.wss = new WebSocket.Server({ server: this.server }); this.setupMiddleware(); this.setupRoutes(); this.setupWebSocket(); this.startMonitoring(); } setupMiddleware() { this.app.use(cors()); this.app.use(express.json()); } setupRoutes() { this.app.get('/health', (req, res) => { res.json({ status: 'healthy', timestamp: new Date().toISOString(), metrics: this.metrics.size, agents: this.agentPerformance.size }); }); this.app.get('/api/v1/dashboard', (req, res) => { res.json(this.getPerformanceDashboard()); }); this.app.get('/api/v1/agents/:agentId/performance', (req, res) => { const { agentId } = req.params; const performance = this.agentPerformance.get(agentId); if (!performance) { return res.status(404).json({ error: 'Agent performance data not found' }); } res.json(performance); }); this.app.get('/api/v1/jobs/metrics', (req, res) => { res.json(this.getJobMetrics()); }); this.app.get('/api/v1/system/metrics', (req, res) => { res.json(this.getSystemMetrics()); }); this.app.get('/api/v1/trends', (req, res) => { const { period = '24h' } = req.query; res.json(this.getPerformanceTrends(period)); }); this.app.get('/api/v1/efficiency', (req, res) => { res.json(this.getEfficiencyReport()); }); } setupWebSocket() { this.wss.on('connection', (ws) => { console.log('New WebSocket connection to performance monitor'); ws.send(JSON.stringify({ type: 'performance_data', data: this.getPerformanceDashboard() })); ws.on('message', (message) => { try { const data = JSON.parse(message); this.handleWebSocketMessage(ws, data); } catch (error) { console.error('Error parsing WebSocket message:', error); } }); ws.on('close', () => { console.log('WebSocket connection to performance monitor closed'); }); }); } handleWebSocketMessage(ws, data) { switch (data.type) { case 'agent_performance_update': this.updateAgentPerformance(data.agentId, data.metrics); break; case 'job_completed': this.recordJobCompletion(data.jobId, data.agentId, data.duration, data.success); break; case 'system_metrics': this.updateSystemMetrics(data.metrics); break; default: console.log('Unknown performance message type:', data.type); } } updateAgentPerformance(agentId, metrics) { if (!this.agentPerformance.has(agentId)) { this.agentPerformance.set(agentId, { agentId, totalJobs: 0, completedJobs: 0, failedJobs: 0, averageCompletionTime: 0, efficiency: 0, lastUpdated: new Date(), history: [] }); } const performance = this.agentPerformance.get(agentId); Object.assign(performance, metrics); performance.lastUpdated = new Date(); performance.history.push({ timestamp: new Date(), ...metrics }); if (performance.history.length > 100) { performance.history = performance.history.slice(-100); } this.broadcastPerformanceUpdate(agentId, performance); } recordJobCompletion(jobId, agentId, duration, success) { if (this.agentPerformance.has(agentId)) { const performance = this.agentPerformance.get(agentId); performance.totalJobs++; if (success) { performance.completedJobs++; } else { performance.failedJobs++; } const totalTime = performance.averageCompletionTime * (performance.completedJobs - 1) + duration; performance.averageCompletionTime = totalTime / performance.completedJobs; performance.efficiency = performance.completedJobs / performance.totalJobs; } this.systemMetrics.totalJobs++; if (success) { this.systemMetrics.completedJobs++; } else { this.systemMetrics.failedJobs++; } const totalTime = this.systemMetrics.averageCompletionTime * (this.systemMetrics.completedJobs - 1) + duration; this.systemMetrics.averageCompletionTime = totalTime / this.systemMetrics.completedJobs; this.jobMetrics.set(jobId, { jobId, agentId, duration, success, completedAt: new Date() }); this.broadcastJobCompletion(jobId, agentId, duration, success); } updateSystemMetrics(metrics) { Object.assign(this.systemMetrics, metrics); this.broadcastSystemMetrics(this.systemMetrics); } getPerformanceDashboard() { const agents = Array.from(this.agentPerformance.entries()).map(([id, performance]) => ({ agentId: id, ...performance })); const systemHealth = this.calculateSystemHealth(); return { timestamp: new Date().toISOString(), systemHealth, agents, systemMetrics: this.systemMetrics, totalJobs: this.jobMetrics.size, uptime: Date.now() - this.systemMetrics.systemUptime }; } calculateSystemHealth() { const totalAgents = this.agentPerformance.size; if (totalAgents === 0) return 0; const activeAgents = Array.from(this.agentPerformance.values()) .filter(agent => agent.efficiency > 0.8).length; const systemEfficiency = this.systemMetrics.completedJobs / Math.max(this.systemMetrics.totalJobs, 1); const agentEfficiency = activeAgents / totalAgents; return Math.round((systemEfficiency * 0.6 + agentEfficiency * 0.4) * 100); } getJobMetrics() { const completedJobs = Array.from(this.jobMetrics.values()) .filter(job => job.success); const failedJobs = Array.from(this.jobMetrics.values()) .filter(job => !job.success); const averageDuration = completedJobs.length > 0 ? completedJobs.reduce((sum, job) => sum + job.duration, 0) / completedJobs.length : 0; return { total: this.jobMetrics.size, completed: completedJobs.length, failed: failedJobs.length, successRate: completedJobs.length / Math.max(this.jobMetrics.size, 1), averageDuration: Math.round(averageDuration), completionRate: this.calculateCompletionRate() }; } calculateCompletionRate() { const now = new Date(); const last24Hours = new Date(now - 24 * 60 * 60 * 1000); const recentJobs = Array.from(this.jobMetrics.values()) .filter(job => job.completedAt > last24Hours); const completedJobs = recentJobs.filter(job => job.success); return completedJobs.length / Math.max(recentJobs.length, 1); } getSystemMetrics() { return { ...this.systemMetrics, uptime: Date.now() - this.systemMetrics.systemUptime, memoryUsage: process.memoryUsage(), cpuUsage: process.cpuUsage() }; } getPerformanceTrends(period) { const now = new Date(); let startTime; switch (period) { case '1h': startTime = new Date(now - 60 * 60 * 1000); break; case '24h': startTime = new Date(now - 24 * 60 * 60 * 1000); break; case '7d': startTime = new Date(now - 7 * 24 * 60 * 60 * 1000); break; default: startTime = new Date(now - 24 * 60 * 60 * 1000); } const trends = { period, startTime, endTime: now, jobCompletions: [], agentEfficiency: [], systemHealth: [] }; const hours = Math.ceil((now - startTime) / (60 * 60 * 1000)); for (let i = 0; i < hours; i++) { const hourStart = new Date(startTime.getTime() + i * 60 * 60 * 1000); const hourEnd = new Date(hourStart.getTime() + 60 * 60 * 1000); const hourJobs = Array.from(this.jobMetrics.values()) .filter(job => job.completedAt >= hourStart && job.completedAt < hourEnd); trends.jobCompletions.push({ timestamp: hourStart, completed: hourJobs.filter(job => job.success).length, failed: hourJobs.filter(job => !job.success).length }); } return trends; } getEfficiencyReport() { const agents = Array.from(this.agentPerformance.values()); const report = { timestamp: new Date().toISOString(), overallEfficiency: this.calculateSystemHealth(), agentRankings: agents .sort((a, b) => b.efficiency - a.efficiency) .map(agent => ({ agentId: agent.agentId, efficiency: Math.round(agent.efficiency * 100), completedJobs: agent.completedJobs, averageCompletionTime: Math.round(agent.averageCompletionTime) })), recommendations: this.generateRecommendations() }; return report; } generateRecommendations() { const recommendations = []; const agents = Array.from(this.agentPerformance.values()); const underperformingAgents = agents.filter(agent => agent.efficiency < 0.7); if (underperformingAgents.length > 0) { recommendations.push({ type: 'performance', priority: 'high', message: `${underperformingAgents.length} agent(s) are underperforming. Consider reassigning tasks or providing additional support.`, agents: underperformingAgents.map(a => a.agentId) }); } const efficiencies = agents.map(a => a.efficiency); const maxEfficiency = Math.max(...efficiencies); const minEfficiency = Math.min(...efficiencies); if (maxEfficiency - minEfficiency > 0.3) { recommendations.push({ type: 'load_balancing', priority: 'medium', message: 'Significant load imbalance detected. Consider redistributing tasks across agents.', details: { maxEfficiency: Math.round(maxEfficiency * 100), minEfficiency: Math.round(minEfficiency * 100) } }); } const systemHealth = this.calculateSystemHealth(); if (systemHealth < 70) { recommendations.push({ type: 'system_health', priority: 'high', message: 'System health is below optimal levels. Review overall performance and resource allocation.', currentHealth: systemHealth }); } return recommendations; } broadcastPerformanceUpdate(agentId, performance) { this.broadcast({ type: 'agent_performance_updated', agentId, data: performance }); } broadcastJobCompletion(jobId, agentId, duration, success) { this.broadcast({ type: 'job_completion_recorded', jobId, agentId, duration, success, timestamp: new Date().toISOString() }); } broadcastSystemMetrics(metrics) { this.broadcast({ type: 'system_metrics_updated', data: metrics }); } broadcast(message) { const data = JSON.stringify(message); this.wss.clients.forEach(client => { if (client.readyState === WebSocket.OPEN) { client.send(data); } }); } startMonitoring() { setInterval(() => { this.updateSystemMetrics({ memoryUsage: process.memoryUsage(), cpuUsage: process.cpuUsage() }); }, 30000); setInterval(() => { this.cleanupOldMetrics(); }, 3600000); } cleanupOldMetrics() { const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);  for (const [jobId, job] of this.jobMetrics) { if (job.completedAt < cutoff) { this.jobMetrics.delete(jobId); } } for (const [agentId, performance] of this.agentPerformance) { performance.history = performance.history.filter(entry => entry.timestamp > cutoff); } } start(port = 9003) { this.server.listen(port, () => { console.log(`Performance Monitor running on port ${port}`); console.log(`WebSocket server running on ws: console.log(`Dashboard available at http: }); } } const monitor = new PerformanceMonitor(); monitor.start(); module.exports = PerformanceMonitor;
