#!/usr/bin/env node /** * NEXUS Platform Load Testing Script * Comprehensive performance testing for production validation */ const http = require('http'); const https = require('https'); const { performance } = require('perf_hooks'); const CONFIG = { BACKEND_URL: process.env.BACKEND_URL || 'http: FRONTEND_URL: process.env.FRONTEND_URL || 'http: CONCURRENT_USERS: parseInt(process.env.CONCURRENT_USERS) || 50, REQUESTS_PER_USER: parseInt(process.env.REQUESTS_PER_USER) || 100, TEST_DURATION: parseInt(process.env.TEST_DURATION) || 300,  MAX_RESPONSE_TIME: parseInt(process.env.MAX_RESPONSE_TIME) || 2000,  MAX_ERROR_RATE: parseFloat(process.env.MAX_ERROR_RATE) || 5.0,  ENDPOINTS: [ { path: '/health', method: 'GET', weight: 20 }, { path: '/', method: 'GET', weight: 15 }, { path: '/test', method: 'GET', weight: 10 }, { path: '/docs', method: 'GET', weight: 5 }, { path: '/api/auth/login', method: 'POST', weight: 10, body: { username: 'test@example.com', password: 'testpass123' } }, { path: '/api/auth/register', method: 'POST', weight: 5, body: { username: 'test@example.com', password: 'testpass123', email: 'test@example.com' } }, { path: '/api/accounts', method: 'GET', weight: 15 }, { path: '/api/transactions', method: 'GET', weight: 10 }, { path: '/api/analytics', method: 'GET', weight: 10 } ] }; const results = { startTime: null, endTime: null, totalRequests: 0, successfulRequests: 0, failedRequests: 0, responseTimes: [], errors: [], statusCodes: {}, throughput: 0, averageResponseTime: 0, p95ResponseTime: 0, p99ResponseTime: 0, errorRate: 0 }; function log(message, level = 'INFO') { const timestamp = new Date().toISOString(); console.log(`[${timestamp}] [${level}] ${message}`); } function makeRequest(url, options = {}) { return new Promise((resolve, reject) => { const startTime = performance.now(); const isHttps = url.startsWith('https'); const client = isHttps ? https : http; const requestOptions = { method: options.method || 'GET', headers: { 'Content-Type': 'application/json', 'User-Agent': 'NEXUS-LoadTest/1.0', ...options.headers }, timeout: 10000 }; if (options.body) { requestOptions.headers['Content-Length'] = Buffer.byteLength(JSON.stringify(options.body)); } const req = client.request(url, requestOptions, (res) => { let data = ''; res.on('data', (chunk) => { data += chunk; }); res.on('end', () => { const endTime = performance.now(); const responseTime = endTime - startTime; resolve({ statusCode: res.statusCode, responseTime, data: data.length > 1000 ? data.substring(0, 1000) + '...' : data, headers: res.headers }); }); }); req.on('error', (error) => { const endTime = performance.now(); const responseTime = endTime - startTime; reject({ error: error.message, responseTime, statusCode: 0 }); }); req.on('timeout', () => { req.destroy(); reject({ error: 'Request timeout', responseTime: 10000, statusCode: 0 }); }); if (options.body) { req.write(JSON.stringify(options.body)); } req.end(); }); } function selectEndpoint() { const totalWeight = CONFIG.ENDPOINTS.reduce((sum, endpoint) => sum + endpoint.weight, 0); let random = Math.random() * totalWeight; for (const endpoint of CONFIG.ENDPOINTS) { random -= endpoint.weight; if (random <= 0) { return endpoint; } } return CONFIG.ENDPOINTS[0]; } async function runUserSession(userId) { const userResults = { requests: 0, successful: 0, failed: 0, responseTimes: [], errors: [] }; log(`Starting user session ${userId}`); for (let i = 0; i < CONFIG.REQUESTS_PER_USER; i++) { if (Date.now() - results.startTime > CONFIG.TEST_DURATION * 1000) { break; } const endpoint = selectEndpoint(); const url = `${CONFIG.BACKEND_URL}${endpoint.path}`; try { const response = await makeRequest(url, { method: endpoint.method, body: endpoint.body }); userResults.requests++; userResults.responseTimes.push(response.responseTime); if (response.statusCode >= 200 && response.statusCode < 400) { userResults.successful++; } else { userResults.failed++; userResults.errors.push({ url, statusCode: response.statusCode, response: response.data }); } results.statusCodes[response.statusCode] = (results.statusCodes[response.statusCode] || 0) + 1; } catch (error) { userResults.requests++; userResults.failed++; userResults.errors.push({ url, error: error.error || error.message, responseTime: error.responseTime }); } await new Promise(resolve => setTimeout(resolve, Math.random() * 100)); } log(`User session ${userId} completed: ${userResults.successful}/${userResults.requests} successful`); return userResults; } function calculateStatistics() { results.totalRequests = results.responseTimes.length; results.successfulRequests = results.responseTimes.filter((_, i) => !results.errors[i]).length; results.failedRequests = results.totalRequests - results.successfulRequests; if (results.responseTimes.length > 0) { results.responseTimes.sort((a, b) => a - b); results.averageResponseTime = results.responseTimes.reduce((sum, time) => sum + time, 0) / results.responseTimes.length; results.p95ResponseTime = results.responseTimes[Math.floor(results.responseTimes.length * 0.95)]; results.p99ResponseTime = results.responseTimes[Math.floor(results.responseTimes.length * 0.99)]; } results.errorRate = results.totalRequests > 0 ? (results.failedRequests / results.totalRequests) * 100 : 0; results.throughput = results.totalRequests / ((results.endTime - results.startTime) / 1000); } function printResults() { console.log('\n' + '='.repeat(80)); console.log('🚀 NEXUS Platform Load Testing Results'); console.log('='.repeat(80)); console.log(`\n📊 Test Configuration:`); console.log(`   Concurrent Users: ${CONFIG.CONCURRENT_USERS}`); console.log(`   Requests per User: ${CONFIG.REQUESTS_PER_USER}`); console.log(`   Test Duration: ${CONFIG.TEST_DURATION}s`); console.log(`   Backend URL: ${CONFIG.BACKEND_URL}`); console.log(`\n📈 Performance Metrics:`); console.log(`   Total Requests: ${results.totalRequests}`); console.log(`   Successful Requests: ${results.successfulRequests}`); console.log(`   Failed Requests: ${results.failedRequests}`); console.log(`   Error Rate: ${results.errorRate.toFixed(2)}%`); console.log(`   Throughput: ${results.throughput.toFixed(2)} requests/second`); console.log(`\n⏱️ Response Times:`); console.log(`   Average: ${results.averageResponseTime.toFixed(2)}ms`); console.log(`   95th Percentile: ${results.p95ResponseTime.toFixed(2)}ms`); console.log(`   99th Percentile: ${results.p99ResponseTime.toFixed(2)}ms`); console.log(`\n📋 Status Code Distribution:`); Object.entries(results.statusCodes).forEach(([code, count]) => { console.log(`   ${code}: ${count} requests`); }); console.log(`\n🎯 Threshold Validation:`); const responseTimePass = results.averageResponseTime <= CONFIG.MAX_RESPONSE_TIME; const errorRatePass = results.errorRate <= CONFIG.MAX_ERROR_RATE; console.log(`   Response Time: ${responseTimePass ? '✅ PASS' : '❌ FAIL'} (${results.averageResponseTime.toFixed(2)}ms <= ${CONFIG.MAX_RESPONSE_TIME}ms)`); console.log(`   Error Rate: ${errorRatePass ? '✅ PASS' : '❌ FAIL'} (${results.errorRate.toFixed(2)}% <= ${CONFIG.MAX_ERROR_RATE}%)`); const overallPass = responseTimePass && errorRatePass; console.log(`\n🏆 Overall Result: ${overallPass ? '✅ PASS' : '❌ FAIL'}`); if (!overallPass) { console.log(`\n⚠️  Issues Found:`); if (!responseTimePass) { console.log(`   - Average response time exceeds threshold`); } if (!errorRatePass) { console.log(`   - Error rate exceeds threshold`); } } console.log('\n' + '='.repeat(80)); } async function runLoadTest() { log('Starting NEXUS Platform Load Test'); log(`Configuration: ${CONFIG.CONCURRENT_USERS} users, ${CONFIG.REQUESTS_PER_USER} requests each`); results.startTime = Date.now(); const userPromises = []; for (let i = 0; i < CONFIG.CONCURRENT_USERS; i++) { userPromises.push(runUserSession(i + 1)); } const userResults = await Promise.all(userPromises); results.endTime = Date.now(); userResults.forEach(userResult => { results.responseTimes.push(...userResult.responseTimes); results.errors.push(...userResult.errors); }); calculateStatistics(); printResults(); const responseTimePass = results.averageResponseTime <= CONFIG.MAX_RESPONSE_TIME; const errorRatePass = results.errorRate <= CONFIG.MAX_ERROR_RATE; process.exit(responseTimePass && errorRatePass ? 0 : 1); } async function healthCheck() { try { log('Performing health check...'); const response = await makeRequest(`${CONFIG.BACKEND_URL}/health`); if (response.statusCode === 200) { log('✅ Backend health check passed'); return true; } else { log(`❌ Backend health check failed: ${response.statusCode}`); return false; } } catch (error) { log(`❌ Backend health check failed: ${error.error || error.message}`); return false; } } async function main() { try { const isHealthy = await healthCheck(); if (!isHealthy) { log('Backend is not healthy. Exiting load test.'); process.exit(1); } await runLoadTest(); } catch (error) { log(`Load test failed: ${error.message}`, 'ERROR'); process.exit(1); } } process.on('SIGINT', () => { log('Load test interrupted. Calculating partial results...'); results.endTime = Date.now(); calculateStatistics(); printResults(); process.exit(1); }); if (require.main === module) { main(); } module.exports = { runLoadTest, CONFIG };
