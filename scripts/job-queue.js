#!/usr/bin/env node /** * NEXUS Platform - Job Queue Manager * Manages job queuing, prioritization, and distribution */ const express = require('express'); const WebSocket = require('ws'); const http = require('http'); const cors = require('cors'); class JobQueueManager { constructor() { this.jobQueue = []; this.priorityLevels = { P0: 0,  P1: 1,  P2: 2,  P3: 3   }; this.jobTypes = { security_audit: { priority: 'P0', estimatedDuration: 120, requiredSkills: ['security', 'audit'], preferredAgents: ['agent1'], fallbackAgents: ['agent3', 'agent5'] }, compliance_check: { priority: 'P1', estimatedDuration: 90, requiredSkills: ['compliance'], preferredAgents: ['agent1'], fallbackAgents: ['agent5'] }, backend_development: { priority: 'P0', estimatedDuration: 240, requiredSkills: ['backend', 'apis'], preferredAgents: ['agent3'], fallbackAgents: ['agent1', 'agent4'] }, api_standardization: { priority: 'P0', estimatedDuration: 180, requiredSkills: ['apis', 'backend'], preferredAgents: ['agent3'], fallbackAgents: ['agent1'] }, infrastructure_setup: { priority: 'P0', estimatedDuration: 300, requiredSkills: ['infrastructure', 'deployment'], preferredAgents: ['agent4'], fallbackAgents: ['agent1', 'agent3'] }, deployment_automation: { priority: 'P1', estimatedDuration: 180, requiredSkills: ['deployment', 'devops'], preferredAgents: ['agent4'], fallbackAgents: ['agent3'] }, test_automation: { priority: 'P1', estimatedDuration: 150, requiredSkills: ['testing', 'automation'], preferredAgents: ['agent5'], fallbackAgents: ['agent2', 'agent3'] }, qa_validation: { priority: 'P1', estimatedDuration: 120, requiredSkills: ['qa', 'validation'], preferredAgents: ['agent5'], fallbackAgents: ['agent2', 'agent3'] }, integration_testing: { priority: 'P0', estimatedDuration: 200, requiredSkills: ['testing', 'backend', 'frontend'], preferredAgents: ['agent5', 'agent3'], fallbackAgents: ['agent2', 'agent1'] }, performance_optimization: { priority: 'P1', estimatedDuration: 180, requiredSkills: ['performance', 'backend', 'infrastructure'], preferredAgents: ['agent5', 'agent3', 'agent4'], fallbackAgents: ['agent1'] } }; this.app = express(); this.server = http.createServer(this.app); this.wss = new WebSocket.Server({ server: this.server }); this.setupMiddleware(); this.setupRoutes(); this.setupWebSocket(); this.startJobProcessing(); } setupMiddleware() { this.app.use(cors()); this.app.use(express.json()); } setupRoutes() { this.app.get('/health', (req, res) => { res.json({ status: 'healthy', timestamp: new Date().toISOString(), queue_length: this.jobQueue.length, processing: this.jobQueue.filter(j => j.status === 'in_progress').length }); }); this.app.post('/api/v1/jobs/submit', (req, res) => { const job = this.createJob(req.body); this.addJob(job); res.json({ status: 'success', message: 'Job submitted successfully', job_id: job.id, estimated_wait_time: this.calculateEstimatedWaitTime(job) }); }); this.app.get('/api/v1/jobs/:jobId', (req, res) => { const { jobId } = req.params; const job = this.jobQueue.find(j => j.id === jobId); if (!job) { return res.status(404).json({ error: 'Job not found' }); } res.json(job); }); this.app.get('/api/v1/jobs', (req, res) => { const { status, priority, type } = req.query; let filteredJobs = this.jobQueue; if (status) { filteredJobs = filteredJobs.filter(job => job.status === status); } if (priority) { filteredJobs = filteredJobs.filter(job => job.priority === priority); } if (type) { filteredJobs = filteredJobs.filter(job => job.type === type); } res.json({ total: filteredJobs.length, jobs: filteredJobs, summary: this.getQueueSummary() }); }); this.app.post('/api/v1/jobs/:jobId/cancel', (req, res) => { const { jobId } = req.params; const job = this.jobQueue.find(j => j.id === jobId); if (!job) { return res.status(404).json({ error: 'Job not found' }); } if (job.status === 'completed') { return res.status(400).json({ error: 'Cannot cancel completed job' }); } job.status = 'cancelled'; job.cancelledAt = new Date(); if (job.assignedAgent) { this.removeJobFromAgent(job); } res.json({ status: 'success', message: 'Job cancelled successfully' }); }); this.app.get('/api/v1/job-types', (req, res) => { res.json(this.jobTypes); }); this.app.get('/api/v1/queue/stats', (req, res) => { res.json(this.getQueueStatistics()); }); } setupWebSocket() { this.wss.on('connection', (ws) => { console.log('New WebSocket connection to job queue'); ws.send(JSON.stringify({ type: 'queue_status', data: this.getQueueSummary() })); ws.on('message', (message) => { try { const data = JSON.parse(message); this.handleWebSocketMessage(ws, data); } catch (error) { console.error('Error parsing WebSocket message:', error); } }); ws.on('close', () => { console.log('WebSocket connection to job queue closed'); }); }); } createJob(jobData) { const jobType = this.jobTypes[jobData.type]; if (!jobType) { throw new Error(`Unknown job type: ${jobData.type}`); } const job = { id: this.generateJobId(), type: jobData.type, title: jobData.title || jobType.title || jobData.type, description: jobData.description || '', priority: jobData.priority || jobType.priority, estimated_duration: jobData.estimated_duration || jobType.estimatedDuration, required_skills: jobData.required_skills || jobType.requiredSkills, preferred_agents: jobData.preferred_agents || jobType.preferredAgents, fallback_agents: jobData.fallback_agents || jobType.fallbackAgents, dependencies: jobData.dependencies || [], deliverables: jobData.deliverables || [], status: 'queued', created_at: new Date(), assigned_agent: null, assigned_at: null, started_at: null, completed_at: null, progress: 0, result: null, error: null }; return job; } addJob(job) { this.jobQueue.push(job); this.sortQueue(); console.log(`Job ${job.id} added to queue:`, { type: job.type, priority: job.priority, estimated_duration: job.estimated_duration }); this.broadcast({ type: 'job_added', job_id: job.id, data: job }); } sortQueue() { this.jobQueue.sort((a, b) => { const priorityDiff = this.priorityLevels[a.priority] - this.priorityLevels[b.priority]; if (priorityDiff !== 0) return priorityDiff; return a.created_at - b.created_at; }); } calculateEstimatedWaitTime(job) { const queuedJobs = this.jobQueue.filter(j => j.status === 'queued' && this.priorityLevels[j.priority] <= this.priorityLevels[job.priority] ); const jobIndex = queuedJobs.findIndex(j => j.id === job.id); if (jobIndex === -1) return 0; let waitTime = 0; for (let i = 0; i < jobIndex; i++) { waitTime += queuedJobs[i].estimated_duration || 60; } return waitTime; } getQueueSummary() { const summary = { total: this.jobQueue.length, by_status: { queued: 0, assigned: 0, in_progress: 0, completed: 0, cancelled: 0, failed: 0 }, by_priority: { P0: 0, P1: 0, P2: 0, P3: 0 }, by_type: {} }; for (const job of this.jobQueue) { summary.by_status[job.status]++; summary.by_priority[job.priority]++; if (!summary.by_type[job.type]) { summary.by_type[job.type] = 0; } summary.by_type[job.type]++; } return summary; } getQueueStatistics() { const now = new Date(); const last24Hours = new Date(now - 24 * 60 * 60 * 1000); const recentJobs = this.jobQueue.filter(job => job.created_at > last24Hours); const completedJobs = recentJobs.filter(job => job.status === 'completed'); const avgCompletionTime = completedJobs.length > 0 ? completedJobs.reduce((sum, job) => { const duration = job.completed_at - job.started_at; return sum + duration; }, 0) / completedJobs.length : 0; return { total_jobs: this.jobQueue.length, recent_jobs_24h: recentJobs.length, completed_jobs_24h: completedJobs.length, average_completion_time: Math.round(avgCompletionTime / 60000),  queue_efficiency: completedJobs.length / Math.max(recentJobs.length, 1), oldest_queued_job: this.getOldestQueuedJob(), current_load: this.calculateCurrentLoad() }; } getOldestQueuedJob() { const queuedJobs = this.jobQueue.filter(job => job.status === 'queued'); if (queuedJobs.length === 0) return null; const oldest = queuedJobs.reduce((oldest, job) => job.created_at < oldest.created_at ? job : oldest ); return { job_id: oldest.id, created_at: oldest.created_at, wait_time: Math.round((new Date() - oldest.created_at) / 60000)  }; } calculateCurrentLoad() { const inProgressJobs = this.jobQueue.filter(job => job.status === 'in_progress'); const totalEstimatedDuration = inProgressJobs.reduce((sum, job) => sum + (job.estimated_duration || 60), 0 ); return { active_jobs: inProgressJobs.length, total_estimated_duration: totalEstimatedDuration, load_percentage: Math.min(100, (totalEstimatedDuration / 480) * 100)  }; } handleWebSocketMessage(ws, data) { switch (data.type) { case 'get_queue_status': ws.send(JSON.stringify({ type: 'queue_status', data: this.getQueueSummary() })); break; case 'get_job_details': const job = this.jobQueue.find(j => j.id === data.job_id); if (job) { ws.send(JSON.stringify({ type: 'job_details', data: job })); } break; default: console.log('Unknown WebSocket message type:', data.type); } } startJobProcessing() { setInterval(() => { this.processQueue(); }, 5000); setInterval(() => { this.cleanupOldJobs(); }, 3600000); setInterval(() => { this.monitorJobTimeouts(); }, 60000); } processQueue() { const queuedJobs = this.jobQueue.filter(job => job.status === 'queued'); for (const job of queuedJobs) { if (this.canProcessJob(job)) { this.tryAssignJob(job); } } } canProcessJob(job) { if (!job.dependencies || job.dependencies.length === 0) { return true; } return job.dependencies.every(depId => { const depJob = this.jobQueue.find(j => j.id === depId); return depJob && depJob.status === 'completed'; }); } tryAssignJob(job) { job.status = 'ready_for_assignment'; this.broadcast({ type: 'job_ready_for_assignment', job_id: job.id, data: job }); } assignJob(jobId, agentId) { const job = this.jobQueue.find(j => j.id === jobId); if (!job) return false; job.status = 'assigned'; job.assigned_agent = agentId; job.assigned_at = new Date(); this.broadcast({ type: 'job_assigned', job_id: jobId, agent_id: agentId, data: job }); return true; } startJob(jobId) { const job = this.jobQueue.find(j => j.id === jobId); if (!job) return false; job.status = 'in_progress'; job.started_at = new Date(); job.progress = 0; this.broadcast({ type: 'job_started', job_id: jobId, data: job }); return true; } updateJobProgress(jobId, progress, notes) { const job = this.jobQueue.find(j => j.id === jobId); if (!job) return false; job.progress = Math.min(100, Math.max(0, progress)); job.last_updated = new Date(); if (notes) job.notes = notes; this.broadcast({ type: 'job_progress_updated', job_id: jobId, data: { progress, notes } }); return true; } completeJob(jobId, result) { const job = this.jobQueue.find(j => j.id === jobId); if (!job) return false; job.status = 'completed'; job.completed_at = new Date(); job.progress = 100; job.result = result; this.broadcast({ type: 'job_completed', job_id: jobId, data: { result } }); return true; } failJob(jobId, error) { const job = this.jobQueue.find(j => j.id === jobId); if (!job) return false; job.status = 'failed'; job.completed_at = new Date(); job.error = error; this.broadcast({ type: 'job_failed', job_id: jobId, data: { error } }); return true; } removeJobFromAgent(job) { console.log(`Removing job ${job.id} from agent ${job.assigned_agent}`); } monitorJobTimeouts() { const now = new Date(); const timeoutThreshold = 2 * 60 * 60 * 1000;  const timeoutJobs = this.jobQueue.filter(job => job.status === 'in_progress' && (now - job.started_at) > timeoutThreshold ); for (const job of timeoutJobs) { console.log(`Job ${job.id} timed out`); this.failJob(job.id, 'Job timed out'); } } cleanupOldJobs() { const cutoff = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);  const initialLength = this.jobQueue.length; this.jobQueue = this.jobQueue.filter(job => job.status !== 'completed' || job.completed_at > cutoff ); const removedCount = initialLength - this.jobQueue.length; if (removedCount > 0) { console.log(`Cleaned up ${removedCount} old completed jobs`); } } broadcast(message) { const data = JSON.stringify(message); this.wss.clients.forEach(client => { if (client.readyState === WebSocket.OPEN) { client.send(data); } }); } generateJobId() { return 'job_' + Math.random().toString(36).substr(2, 9); } start(port = 9001) { this.server.listen(port, () => { console.log(`Job Queue Manager running on port ${port}`); console.log(`WebSocket server running on ws: }); } } const jobQueue = new JobQueueManager(); jobQueue.start(); module.exports = JobQueueManager;
