#!/usr/bin/env node /** * NEXUS Platform - Agent Load Balancer * Intelligent load balancing and job distribution across all agents */ const express = require('express'); const WebSocket = require('ws'); const http = require('http'); const cors = require('cors'); class AgentLoadBalancer { constructor() { this.agents = new Map(); this.jobQueue = []; this.performanceMetrics = new Map(); this.specializationMatrix = new Map(); this.app = express(); this.server = http.createServer(this.app); this.wss = new WebSocket.Server({ server: this.server }); this.setupMiddleware(); this.setupRoutes(); this.setupWebSocket(); this.initializeSpecializationMatrix(); this.startLoadBalancing(); } setupMiddleware() { this.app.use(cors()); this.app.use(express.json()); this.app.use(express.static('public')); } setupRoutes() { this.app.get('/health', (req, res) => { res.json({ status: 'healthy', timestamp: new Date().toISOString(), agents: this.agents.size, jobs: this.jobQueue.length }); }); this.app.post('/api/v1/agents/register', (req, res) => { const { agent_id, specialization, capacity, skills } = req.body; this.registerAgent(agent_id, { specialization, capacity, skills, currentLoad: 0, activeJobs: [], isAvailable: true, registeredAt: new Date() }); res.json({ status: 'success', message: `Agent ${agent_id} registered successfully`, agent_id }); }); this.app.post('/api/v1/agents/:agentId/status', (req, res) => { const { agentId } = req.params; const { load, isAvailable, activeJobs } = req.body; this.updateAgentStatus(agentId, { load, isAvailable, activeJobs }); res.json({ status: 'success', message: `Agent ${agentId} status updated` }); }); this.app.post('/api/v1/jobs/submit', (req, res) => { const job = { id: this.generateJobId(), ...req.body, status: 'queued', createdAt: new Date(), assignedAgent: null }; this.addJob(job); res.json({ status: 'success', message: 'Job submitted successfully', job_id: job.id }); }); this.app.get('/api/v1/jobs/:jobId', (req, res) => { const { jobId } = req.params; const job = this.jobQueue.find(j => j.id === jobId); if (!job) { return res.status(404).json({ error: 'Job not found' }); } res.json(job); }); this.app.get('/api/v1/agents/:agentId', (req, res) => { const { agentId } = req.params; const agent = this.agents.get(agentId); if (!agent) { return res.status(404).json({ error: 'Agent not found' }); } res.json(agent); }); this.app.get('/api/v1/dashboard', (req, res) => { res.json(this.getDashboard()); }); this.app.get('/api/v1/jobs', (req, res) => { res.json({ total: this.jobQueue.length, queued: this.jobQueue.filter(j => j.status === 'queued').length, in_progress: this.jobQueue.filter(j => j.status === 'in_progress').length, completed: this.jobQueue.filter(j => j.status === 'completed').length, jobs: this.jobQueue }); }); } setupWebSocket() { this.wss.on('connection', (ws) => { console.log('New WebSocket connection established'); ws.on('message', (message) => { try { const data = JSON.parse(message); this.handleWebSocketMessage(ws, data); } catch (error) { console.error('Error parsing WebSocket message:', error); } }); ws.on('close', () => { console.log('WebSocket connection closed'); }); }); } initializeSpecializationMatrix() { this.specializationMatrix.set('agent1', { primary: ['security', 'compliance', 'audit', 'encryption'], secondary: ['backend', 'infrastructure', 'testing'], skills: { security: 0.95, compliance: 0.90, audit: 0.85, encryption: 0.90, backend: 0.70, infrastructure: 0.60, testing: 0.65 } }); this.specializationMatrix.set('agent2', { primary: ['frontend', 'ui_ux', 'testing', 'accessibility'], secondary: ['backend', 'infrastructure'], skills: { frontend: 1.00, ui_ux: 0.95, testing: 0.90, accessibility: 0.90, backend: 0.50, infrastructure: 0.40 } }); this.specializationMatrix.set('agent3', { primary: ['backend', 'apis', 'database', 'security'], secondary: ['infrastructure', 'testing'], skills: { backend: 0.90, apis: 0.95, database: 0.85, security: 0.75, infrastructure: 0.60, testing: 0.70 } }); this.specializationMatrix.set('agent4', { primary: ['infrastructure', 'deployment', 'monitoring', 'devops'], secondary: ['security', 'backend'], skills: { infrastructure: 0.95, deployment: 0.90, monitoring: 0.85, devops: 0.90, security: 0.70, backend: 0.60 } }); this.specializationMatrix.set('agent5', { primary: ['testing', 'qa', 'validation', 'performance'], secondary: ['frontend', 'backend', 'security'], skills: { testing: 0.95, qa: 0.90, validation: 0.85, performance: 0.80, frontend: 0.70, backend: 0.65, security: 0.60 } }); } registerAgent(agentId, agentData) { this.agents.set(agentId, agentData); console.log(`Agent ${agentId} registered:`, agentData); this.broadcast({ type: 'agent_registered', agent_id: agentId, data: agentData }); } updateAgentStatus(agentId, statusData) { const agent = this.agents.get(agentId); if (agent) { Object.assign(agent, statusData); console.log(`Agent ${agentId} status updated:`, statusData); this.broadcast({ type: 'agent_status_updated', agent_id: agentId, data: statusData }); } } addJob(job) { this.jobQueue.push(job); console.log(`Job ${job.id} added to queue:`, job); this.distributeJobs(); this.broadcast({ type: 'job_added', job_id: job.id, data: job }); } distributeJobs() { const availableAgents = Array.from(this.agents.entries()) .filter(([id, agent]) => agent.isAvailable && agent.currentLoad < 90) .map(([id, agent]) => id); const queuedJobs = this.jobQueue.filter(job => job.status === 'queued'); for (const job of queuedJobs) { const bestAgent = this.selectBestAgent(job, availableAgents); if (bestAgent) { this.assignJob(job, bestAgent); } } } selectBestAgent(job, availableAgents) { let bestAgent = null; let bestScore = 0; for (const agentId of availableAgents) { const score = this.calculateAgentScore(agentId, job); if (score > bestScore) { bestScore = score; bestAgent = agentId; } } return bestAgent; } calculateAgentScore(agentId, job) { const agent = this.agents.get(agentId); const specialization = this.specializationMatrix.get(agentId); if (!agent || !specialization) return 0; let score = 0; const specializationScore = this.calculateSpecializationScore(specialization, job); score += specializationScore * 0.4; const loadScore = Math.max(0, 1 - (agent.currentLoad / 100)); score += loadScore * 0.3; const performance = this.performanceMetrics.get(agentId) || { efficiency: 0.8 }; score += performance.efficiency * 0.2; score += agent.isAvailable ? 1.0 : 0.0; return score; } calculateSpecializationScore(specialization, job) { const requiredSkills = job.required_skills || []; let score = 0; for (const skill of requiredSkills) { if (specialization.skills[skill]) { score += specialization.skills[skill]; } } return score / requiredSkills.length; } assignJob(job, agentId) { job.status = 'assigned'; job.assignedAgent = agentId; job.assignedAt = new Date(); const agent = this.agents.get(agentId); agent.activeJobs.push(job); agent.currentLoad = Math.min(100, agent.currentLoad + (job.estimated_duration || 60)); console.log(`Job ${job.id} assigned to agent ${agentId}`); this.sendJobToAgent(job, agentId); this.broadcast({ type: 'job_assigned', job_id: job.id, agent_id: agentId, data: job }); } sendJobToAgent(job, agentId) { const message = { type: 'job_assignment', job_id: job.id, assigned_agent: agentId, job_details: job, assigned_at: new Date().toISOString() }; this.broadcast(message); } handleWebSocketMessage(ws, data) { switch (data.type) { case 'job_status_update': this.handleJobStatusUpdate(data); break; case 'job_completed': this.handleJobCompleted(data); break; case 'agent_heartbeat': this.handleAgentHeartbeat(data); break; default: console.log('Unknown WebSocket message type:', data.type); } } handleJobStatusUpdate(data) { const { job_id, agent_id, status, progress } = data; const job = this.jobQueue.find(j => j.id === job_id); if (job) { job.status = status; job.progress = progress; job.lastUpdated = new Date(); console.log(`Job ${job_id} status updated to ${status}`); this.broadcast({ type: 'job_status_updated', job_id, agent_id, data: { status, progress } }); } } handleJobCompleted(data) { const { job_id, agent_id, result } = data; const job = this.jobQueue.find(j => j.id === job_id); if (job) { job.status = 'completed'; job.completedAt = new Date(); job.result = result; const agent = this.agents.get(agent_id); if (agent) { agent.activeJobs = agent.activeJobs.filter(j => j.id !== job_id); agent.currentLoad = Math.max(0, agent.currentLoad - (job.estimated_duration || 60)); } this.updatePerformanceMetrics(agent_id, job); console.log(`Job ${job_id} completed by agent ${agent_id}`); this.broadcast({ type: 'job_completed', job_id, agent_id, data: { result } }); } } handleAgentHeartbeat(data) { const { agent_id, status } = data; const agent = this.agents.get(agent_id); if (agent) { agent.lastHeartbeat = new Date(); agent.isAvailable = status.isAvailable; agent.currentLoad = status.currentLoad; } } updatePerformanceMetrics(agentId, job) { const startTime = job.assignedAt; const endTime = job.completedAt; const duration = endTime - startTime; const estimatedDuration = job.estimated_duration * 60000;  const efficiency = estimatedDuration / duration; if (!this.performanceMetrics.has(agentId)) { this.performanceMetrics.set(agentId, { efficiency: efficiency, completedJobs: 1, totalDuration: duration }); } else { const metrics = this.performanceMetrics.get(agentId); metrics.completedJobs++; metrics.totalDuration += duration; metrics.efficiency = (metrics.efficiency + efficiency) / 2; } } broadcast(message) { const data = JSON.stringify(message); this.wss.clients.forEach(client => { if (client.readyState === WebSocket.OPEN) { client.send(data); } }); } getDashboard() { const agents = Array.from(this.agents.entries()).map(([id, agent]) => ({ agent_id: id, status: agent.isAvailable ? 'available' : 'busy', load: agent.currentLoad, active_jobs: agent.activeJobs.length, efficiency_score: this.performanceMetrics.get(id)?.efficiency || 0.8 })); const jobs = { total: this.jobQueue.length, queued: this.jobQueue.filter(j => j.status === 'queued').length, in_progress: this.jobQueue.filter(j => j.status === 'in_progress').length, completed: this.jobQueue.filter(j => j.status === 'completed').length }; return { timestamp: new Date().toISOString(), overall_status: 'healthy', total_agents: this.agents.size, available_agents: agents.filter(a => a.status === 'available').length, agents, jobs }; } generateJobId() { return 'job_' + Math.random().toString(36).substr(2, 9); } startLoadBalancing() { setInterval(() => { this.checkLoadBalancingTriggers(); }, 30000); setInterval(() => { this.distributeJobs(); }, 10000); setInterval(() => { this.cleanupCompletedJobs(); }, 3600000); } checkLoadBalancingTriggers() { for (const [agentId, agent] of this.agents) { if (agent.currentLoad > 90) { console.log(`Agent ${agentId} is overloaded (${agent.currentLoad}%)`); this.redistributeOverloadedAgent(agentId); } } const timeoutJobs = this.jobQueue.filter(job => { const timeout = (job.estimated_duration || 60) * 1.5 * 60000;  return job.status === 'in_progress' && (new Date() - job.assignedAt) > timeout; }); for (const job of timeoutJobs) { console.log(`Job ${job.id} timed out, reassigning`); this.reassignJob(job); } } redistributeOverloadedAgent(agentId) { const agent = this.agents.get(agentId); const activeJobs = agent.activeJobs; activeJobs.sort((a, b) => { const priorityOrder = { P0: 0, P1: 1, P2: 2, P3: 3 }; return priorityOrder[a.priority] - priorityOrder[b.priority]; }); const jobsToReassign = activeJobs.slice(0, Math.floor(activeJobs.length / 2)); for (const job of jobsToReassign) { this.reassignJob(job); } } reassignJob(job) { if (job.assignedAgent) { const agent = this.agents.get(job.assignedAgent); if (agent) { agent.activeJobs = agent.activeJobs.filter(j => j.id !== job.id); agent.currentLoad = Math.max(0, agent.currentLoad - (job.estimated_duration || 60)); } } job.status = 'queued'; job.assignedAgent = null; job.assignedAt = null; this.distributeJobs(); } cleanupCompletedJobs() { const cutoff = new Date(Date.now() - 24 * 60 * 60 * 1000);  this.jobQueue = this.jobQueue.filter(job => job.status !== 'completed' || job.completedAt > cutoff ); } start(port = 9000) { this.server.listen(port, () => { console.log(`Agent Load Balancer running on port ${port}`); console.log(`WebSocket server running on ws: console.log(`Dashboard available at http: }); } } const loadBalancer = new AgentLoadBalancer(); loadBalancer.start(); module.exports = AgentLoadBalancer;
