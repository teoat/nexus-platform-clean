#!/usr/bin/env node /** * NEXUS Platform - Agent Connection Hub * Central communication hub for all agents */ const express = require('express'); const WebSocket = require('ws'); const http = require('http'); const cors = require('cors'); class AgentConnectionHub { constructor() { this.agents = new Map(); this.connections = new Map(); this.messageHistory = []; this.app = express(); this.server = http.createServer(this.app); this.wss = new WebSocket.Server({ server: this.server }); this.setupMiddleware(); this.setupRoutes(); this.setupWebSocket(); this.startHeartbeat(); } setupMiddleware() { this.app.use(cors()); this.app.use(express.json()); this.app.use(express.static('public')); } setupRoutes() { this.app.get('/health', (req, res) => { res.json({ status: 'healthy', timestamp: new Date().toISOString(), agents: this.agents.size, connections: this.connections.size, messages: this.messageHistory.length }); }); this.app.get('/api/v1/agents', (req, res) => { const agents = Array.from(this.agents.entries()).map(([id, agent]) => ({ id, ...agent, isConnected: this.connections.has(id) })); res.json(agents); }); this.app.get('/api/v1/agents/:agentId', (req, res) => { const { agentId } = req.params; const agent = this.agents.get(agentId); if (!agent) { return res.status(404).json({ error: 'Agent not found' }); } res.json({ id: agentId, ...agent, isConnected: this.connections.has(agentId) }); }); this.app.post('/api/v1/agents/:agentId/message', (req, res) => { const { agentId } = req.params; const { message, type = 'direct' } = req.body; if (!this.agents.has(agentId)) { return res.status(404).json({ error: 'Agent not found' }); } const success = this.sendMessageToAgent(agentId, { type, message, timestamp: new Date().toISOString(), from: 'hub' }); if (success) { res.json({ status: 'success', message: 'Message sent' }); } else { res.status(503).json({ error: 'Agent not connected' }); } }); this.app.post('/api/v1/broadcast', (req, res) => { const { message, type = 'broadcast', exclude = [] } = req.body; const success = this.broadcastMessage({ type, message, timestamp: new Date().toISOString(), from: 'hub' }, exclude); res.json({ status: 'success', message: 'Broadcast sent', recipients: this.connections.size - exclude.length }); }); this.app.get('/api/v1/messages', (req, res) => { const { limit = 100, agentId, type } = req.query; let messages = this.messageHistory; if (agentId) { messages = messages.filter(m => m.agentId === agentId || m.to === agentId); } if (type) { messages = messages.filter(m => m.type === type); } messages = messages.slice(-limit); res.json(messages); }); this.app.get('/api/v1/status', (req, res) => { res.json(this.getStatus()); }); this.app.post('/api/v1/agents/register', (req, res) => { const { agentId, name, specialization, capacity } = req.body; this.registerAgent(agentId, { name, specialization, capacity, registeredAt: new Date(), lastSeen: new Date(), status: 'available' }); res.json({ status: 'success', message: `Agent ${agentId} registered successfully`, agentId }); }); this.app.post('/api/v1/agents/:agentId/status', (req, res) => { const { agentId } = req.params; const { status, load, currentTask } = req.body; if (!this.agents.has(agentId)) { return res.status(404).json({ error: 'Agent not found' }); } this.updateAgentStatus(agentId, { status, load, currentTask }); res.json({ status: 'success', message: 'Agent status updated' }); }); } setupWebSocket() { this.wss.on('connection', (ws, req) => { console.log('New WebSocket connection established'); ws.on('message', (message) => { try { const data = JSON.parse(message); this.handleWebSocketMessage(ws, data); } catch (error) { console.error('Error parsing WebSocket message:', error); ws.send(JSON.stringify({ type: 'error', message: 'Invalid message format' })); } }); ws.on('close', () => { console.log('WebSocket connection closed'); this.handleDisconnection(ws); }); ws.on('error', (error) => { console.error('WebSocket error:', error); this.handleDisconnection(ws); }); }); } handleWebSocketMessage(ws, data) { switch (data.type) { case 'agent_connect': this.handleAgentConnection(ws, data); break; case 'agent_disconnect': this.handleAgentDisconnection(ws, data); break; case 'message': this.handleAgentMessage(ws, data); break; case 'status_update': this.handleStatusUpdate(ws, data); break; case 'heartbeat': this.handleHeartbeat(ws, data); break; case 'task_update': this.handleTaskUpdate(ws, data); break; case 'progress_update': this.handleProgressUpdate(ws, data); break; default: console.log('Unknown message type:', data.type); } } handleAgentConnection(ws, data) { const { agentId, name, specialization, capacity } = data; if (!agentId) { ws.send(JSON.stringify({ type: 'error', message: 'Agent ID is required' })); return; } if (!this.agents.has(agentId)) { this.registerAgent(agentId, { name: name || `Agent ${agentId}`, specialization: specialization || [], capacity: capacity || { maxConcurrentTasks: 3 }, registeredAt: new Date(), lastSeen: new Date(), status: 'available' }); } this.connections.set(agentId, ws); ws.agentId = agentId; this.agents.get(agentId).lastSeen = new Date(); console.log(`Agent ${agentId} connected`); ws.send(JSON.stringify({ type: 'welcome', message: `Welcome ${agentId}! Connected to NEXUS Platform Hub`, agentId, timestamp: new Date().toISOString() })); this.broadcastMessage({ type: 'agent_connected', agentId, message: `Agent ${agentId} has connected`, timestamp: new Date().toISOString() }, [agentId]); } handleAgentDisconnection(ws, data) { const agentId = ws.agentId || data.agentId; if (agentId) { this.connections.delete(agentId); if (this.agents.has(agentId)) { this.agents.get(agentId).status = 'disconnected'; this.agents.get(agentId).lastSeen = new Date(); } console.log(`Agent ${agentId} disconnected`); this.broadcastMessage({ type: 'agent_disconnected', agentId, message: `Agent ${agentId} has disconnected`, timestamp: new Date().toISOString() }, [agentId]); } } handleAgentMessage(ws, data) { const { to, message, type = 'message' } = data; const fromAgentId = ws.agentId; if (!fromAgentId) { ws.send(JSON.stringify({ type: 'error', message: 'Agent not identified' })); return; } const messageData = { type, from: fromAgentId, to, message, timestamp: new Date().toISOString() }; this.messageHistory.push({ ...messageData, agentId: fromAgentId }); if (to) { this.sendMessageToAgent(to, messageData); } else { this.broadcastMessage(messageData, [fromAgentId]); } ws.send(JSON.stringify({ type: 'message_sent', message: 'Message sent successfully', timestamp: new Date().toISOString() })); } handleStatusUpdate(ws, data) { const agentId = ws.agentId; if (!agentId) return; const { status, load, currentTask, progress } = data; this.updateAgentStatus(agentId, { status, load, currentTask, progress, lastSeen: new Date() }); this.broadcastMessage({ type: 'agent_status_updated', agentId, status, load, currentTask, progress, timestamp: new Date().toISOString() }, [agentId]); } handleHeartbeat(ws, data) { const agentId = ws.agentId; if (!agentId) return; if (this.agents.has(agentId)) { this.agents.get(agentId).lastSeen = new Date(); } ws.send(JSON.stringify({ type: 'heartbeat_response', timestamp: new Date().toISOString() })); } handleTaskUpdate(ws, data) { const agentId = ws.agentId; if (!agentId) return; const { taskId, status, progress, notes } = data; this.broadcastMessage({ type: 'task_update', agentId, taskId, status, progress, notes, timestamp: new Date().toISOString() }, [agentId]); } handleProgressUpdate(ws, data) { const agentId = ws.agentId; if (!agentId) return; const { progress, phase, notes } = data; if (this.agents.has(agentId)) { this.agents.get(agentId).progress = progress; this.agents.get(agentId).currentPhase = phase; } this.broadcastMessage({ type: 'progress_update', agentId, progress, phase, notes, timestamp: new Date().toISOString() }, [agentId]); } handleDisconnection(ws) { const agentId = ws.agentId; if (agentId) { this.connections.delete(agentId); if (this.agents.has(agentId)) { this.agents.get(agentId).status = 'disconnected'; this.agents.get(agentId).lastSeen = new Date(); } console.log(`Agent ${agentId} disconnected`); this.broadcastMessage({ type: 'agent_disconnected', agentId, message: `Agent ${agentId} has disconnected`, timestamp: new Date().toISOString() }, [agentId]); } } registerAgent(agentId, agentData) { this.agents.set(agentId, agentData); console.log(`Agent ${agentId} registered:`, agentData); } updateAgentStatus(agentId, statusData) { const agent = this.agents.get(agentId); if (agent) { Object.assign(agent, statusData); } } sendMessageToAgent(agentId, message) { const connection = this.connections.get(agentId); if (connection && connection.readyState === WebSocket.OPEN) { connection.send(JSON.stringify(message)); return true; } return false; } broadcastMessage(message, exclude = []) { let sentCount = 0; this.connections.forEach((ws, agentId) => { if (!exclude.includes(agentId) && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify(message)); sentCount++; } }); return sentCount > 0; } getStatus() { const agents = Array.from(this.agents.entries()).map(([id, agent]) => ({ id, ...agent, isConnected: this.connections.has(id) })); return { timestamp: new Date().toISOString(), totalAgents: this.agents.size, connectedAgents: this.connections.size, agents, totalMessages: this.messageHistory.length, uptime: process.uptime() }; } startHeartbeat() { setInterval(() => { this.connections.forEach((ws, agentId) => { if (ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: 'heartbeat', timestamp: new Date().toISOString() })); } }); }, 30000); setInterval(() => { this.cleanupDisconnectedAgents(); }, 60000); } cleanupDisconnectedAgents() { const now = new Date(); const timeout = 5 * 60 * 1000;  for (const [agentId, agent] of this.agents) { if (now - agent.lastSeen > timeout) { this.connections.delete(agentId); agent.status = 'disconnected'; console.log(`Cleaned up disconnected agent: ${agentId}`); } } } start(port = 9000) { this.server.listen(port, () => { console.log(`Agent Connection Hub running on port ${port}`); console.log(`WebSocket server running on ws: console.log(`Health check available at http: }); } } const hub = new AgentConnectionHub(); hub.start(); module.exports = AgentConnectionHub;
