const express = require('express'); const cors = require('cors'); const helmet = require('helmet'); const morgan = require('morgan'); const cron = require('node-cron'); const winston = require('winston'); const promClient = require('prom-client'); const expressPrometheusMiddleware = require('express-prometheus-middleware'); require('dotenv').config(); const { HealthChecker } = require('./services/healthChecker'); const { AlertManager } = require('./services/alertManager'); const { MetricsCollector } = require('./services/metricsCollector'); const { LogAnalyzer } = require('./services/logAnalyzer'); const { DatabaseMonitor } = require('./services/databaseMonitor'); const { APIMonitor } = require('./services/apiMonitor'); const app = express(); const PORT = process.env.MONITORING_PORT || 3001; app.use(helmet()); app.use(cors()); app.use(morgan('combined')); app.use(expressPrometheusMiddleware({ metricsPath: '/metrics', collectDefaultMetrics: true, requestDurationBuckets: [0.1, 0.5, 1, 1.5, 2, 3, 5, 10], requestLengthBuckets: [512, 1024, 5120, 10240, 51200, 102400], responseLengthBuckets: [512, 1024, 5120, 10240, 51200, 102400], })); const logger = winston.createLogger({ level: 'info', format: winston.format.combine( winston.format.timestamp(), winston.format.errors({ stack: true }), winston.format.json() ), transports: [ new winston.transports.File({ filename: 'logs/error.log', level: 'error' }), new winston.transports.File({ filename: 'logs/combined.log' }), new winston.transports.Console({ format: winston.format.simple() }) ] }); const healthChecker = new HealthChecker(logger); const alertManager = new AlertManager(logger); const metricsCollector = new MetricsCollector(logger); const logAnalyzer = new LogAnalyzer(logger); const databaseMonitor = new DatabaseMonitor(logger); const apiMonitor = new APIMonitor(logger); const httpRequestDuration = new promClient.Histogram({ name: 'http_request_duration_seconds', help: 'Duration of HTTP requests in seconds', labelNames: ['method', 'route', 'status_code'] }); const activeUsers = new promClient.Gauge({ name: 'active_users_total', help: 'Number of active users' }); const apiErrors = new promClient.Counter({ name: 'api_errors_total', help: 'Total number of API errors', labelNames: ['endpoint', 'error_type'] }); app.use((req, res, next) => { const start = Date.now(); res.on('finish', () => { const duration = (Date.now() - start) / 1000; httpRequestDuration .labels(req.method, req.route?.path || req.path, res.statusCode) .observe(duration); }); next(); }); app.get('/health', async (req, res) => { try { const healthStatus = await healthChecker.checkAll(); res.json(healthStatus); } catch (error) { logger.error('Health check failed:', error); res.status(500).json({ status: 'unhealthy', error: error.message }); } }); app.get('/metrics', (req, res) => { res.set('Content-Type', promClient.register.contentType); res.end(promClient.register.metrics()); }); app.get('/dashboard', (req, res) => { res.json({ status: 'operational', services: { backend: healthChecker.getBackendStatus(), database: healthChecker.getDatabaseStatus(), frontend: healthChecker.getFrontendStatus() }, metrics: { activeUsers: activeUsers.get(), apiErrors: apiErrors.get() }, alerts: alertManager.getActiveAlerts(), uptime: process.uptime() }); }); app.get('/alerts', (req, res) => { res.json(alertManager.getAllAlerts()); }); app.post('/alerts/:id/acknowledge', (req, res) => { const { id } = req.params; alertManager.acknowledgeAlert(id); res.json({ message: 'Alert acknowledged' }); }); app.post('/alerts/:id/resolve', (req, res) => { const { id } = req.params; alertManager.resolveAlert(id); res.json({ message: 'Alert resolved' }); }); app.get('/logs/analysis', async (req, res) => { try { const analysis = await logAnalyzer.analyzeLogs(); res.json(analysis); } catch (error) { logger.error('Log analysis failed:', error); res.status(500).json({ error: error.message }); } }); app.get('/database/status', async (req, res) => { try { const status = await databaseMonitor.getStatus(); res.json(status); } catch (error) { logger.error('Database monitoring failed:', error); res.status(500).json({ error: error.message }); } }); app.get('/api/status', async (req, res) => { try { const status = await apiMonitor.getStatus(); res.json(status); } catch (error) { logger.error('API monitoring failed:', error); res.status(500).json({ error: error.message }); } }); cron.schedule('*/5 * * * *', async () => { logger.info('Running scheduled health checks...'); try { const healthStatus = await healthChecker.checkAll(); activeUsers.set(healthStatus.services.backend?.activeUsers || 0); if (healthStatus.status === 'unhealthy') { alertManager.createAlert({ type: 'system', severity: 'critical', message: 'System health check failed', details: healthStatus }); } } catch (error) { logger.error('Scheduled health check failed:', error); } }); cron.schedule('0 * * * *', async () => { logger.info('Running log analysis...'); try { await logAnalyzer.analyzeLogs(); } catch (error) { logger.error('Log analysis failed:', error); } }); cron.schedule('*/10 * * * *', async () => { logger.info('Running database monitoring...'); try { await databaseMonitor.checkDatabaseHealth(); } catch (error) { logger.error('Database monitoring failed:', error); } }); cron.schedule('*/2 * * * *', async () => { logger.info('Running API monitoring...'); try { await apiMonitor.checkAPIHealth(); } catch (error) { logger.error('API monitoring failed:', error); } }); app.use((error, req, res, next) => { logger.error('Unhandled error:', error); apiErrors.inc({ endpoint: req.path, error_type: error.name }); res.status(500).json({ error: 'Internal server error' }); }); app.listen(PORT, () => { logger.info(`Monitoring service started on port ${PORT}`); logger.info(`Health check: http: logger.info(`Metrics: http: logger.info(`Dashboard: http: }); module.exports = app;