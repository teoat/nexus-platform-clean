const axios = require('axios'); const sqlite3 = require('sqlite3').verbose(); class HealthChecker { constructor(logger) { this.logger = logger; this.backendUrl = process.env.BACKEND_URL || 'http: this.frontendUrl = process.env.FRONTEND_URL || 'http: this.databasePath = process.env.DATABASE_PATH || '../backend/nexus.db'; this.healthStatus = { backend: { status: 'unknown', lastCheck: null, responseTime: null }, database: { status: 'unknown', lastCheck: null, responseTime: null }, frontend: { status: 'unknown', lastCheck: null, responseTime: null } }; } async checkAll() { const results = await Promise.allSettled([ this.checkBackend(), this.checkDatabase(), this.checkFrontend() ]); const overallStatus = results.every(result => result.status === 'fulfilled' && result.value.status === 'healthy' ) ? 'healthy' : 'unhealthy'; return { status: overallStatus, timestamp: new Date().toISOString(), services: { backend: this.healthStatus.backend, database: this.healthStatus.database, frontend: this.healthStatus.frontend } }; } async checkBackend() { const startTime = Date.now(); try { const response = await axios.get(`${this.backendUrl}/health`, { timeout: 5000 }); const responseTime = Date.now() - startTime; this.healthStatus.backend = { status: 'healthy', lastCheck: new Date().toISOString(), responseTime: responseTime, details: response.data }; this.logger.info(`Backend health check passed (${responseTime}ms)`); return this.healthStatus.backend; } catch (error) { const responseTime = Date.now() - startTime; this.healthStatus.backend = { status: 'unhealthy', lastCheck: new Date().toISOString(), responseTime: responseTime, error: error.message }; this.logger.error(`Backend health check failed: ${error.message}`); return this.healthStatus.backend; } } async checkDatabase() { const startTime = Date.now(); try { const db = new sqlite3.Database(this.databasePath); return new Promise((resolve, reject) => { db.get('SELECT 1 as test', (err, row) => { const responseTime = Date.now() - startTime; db.close(); if (err) { this.healthStatus.database = { status: 'unhealthy', lastCheck: new Date().toISOString(), responseTime: responseTime, error: err.message }; this.logger.error(`Database health check failed: ${err.message}`); resolve(this.healthStatus.database); } else { this.healthStatus.database = { status: 'healthy', lastCheck: new Date().toISOString(), responseTime: responseTime, details: { test: row.test } }; this.logger.info(`Database health check passed (${responseTime}ms)`); resolve(this.healthStatus.database); } }); }); } catch (error) { const responseTime = Date.now() - startTime; this.healthStatus.database = { status: 'unhealthy', lastCheck: new Date().toISOString(), responseTime: responseTime, error: error.message }; this.logger.error(`Database health check failed: ${error.message}`); return this.healthStatus.database; } } async checkFrontend() { const startTime = Date.now(); try { const response = await axios.get(this.frontendUrl, { timeout: 5000, validateStatus: (status) => status < 500 }); const responseTime = Date.now() - startTime; this.healthStatus.frontend = { status: 'healthy', lastCheck: new Date().toISOString(), responseTime: responseTime, statusCode: response.status }; this.logger.info(`Frontend health check passed (${responseTime}ms)`); return this.healthStatus.frontend; } catch (error) { const responseTime = Date.now() - startTime; this.healthStatus.frontend = { status: 'unhealthy', lastCheck: new Date().toISOString(), responseTime: responseTime, error: error.message }; this.logger.error(`Frontend health check failed: ${error.message}`); return this.healthStatus.frontend; } } getBackendStatus() { return this.healthStatus.backend; } getDatabaseStatus() { return this.healthStatus.database; } getFrontendStatus() { return this.healthStatus.frontend; } } module.exports = { HealthChecker };
