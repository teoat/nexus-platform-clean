const axios = require('axios'); const sqlite3 = require('sqlite3').verbose(); const moment = require('moment'); class MetricsCollector { constructor(logger) { this.logger = logger; this.backendUrl = process.env.BACKEND_URL || 'http: this.databasePath = process.env.DATABASE_PATH || '../backend/nexus.db'; this.metrics = { system: {}, application: {}, database: {}, api: {} }; } async collectAllMetrics() { try { await Promise.all([ this.collectSystemMetrics(), this.collectApplicationMetrics(), this.collectDatabaseMetrics(), this.collectAPIMetrics() ]); this.logger.info('All metrics collected successfully'); return this.metrics; } catch (error) { this.logger.error('Failed to collect metrics:', error); throw error; } } async collectSystemMetrics() { try { const os = require('os'); this.metrics.system = { uptime: process.uptime(), memory: { used: process.memoryUsage().heapUsed, total: process.memoryUsage().heapTotal, external: process.memoryUsage().external, rss: process.memoryUsage().rss }, cpu: { loadAverage: os.loadavg(), cpuCount: os.cpus().length }, platform: { type: os.type(), platform: os.platform(), arch: os.arch(), release: os.release() }, timestamp: new Date().toISOString() }; } catch (error) { this.logger.error('Failed to collect system metrics:', error); this.metrics.system = { error: error.message }; } } async collectApplicationMetrics() { try { const response = await axios.get(`${this.backendUrl}/metrics`, { timeout: 5000 }); this.metrics.application = { backend: { status: 'healthy', responseTime: response.headers['x-response-time'] || 'unknown', version: response.headers['x-app-version'] || 'unknown' }, timestamp: new Date().toISOString() }; } catch (error) { this.logger.error('Failed to collect application metrics:', error); this.metrics.application = { backend: { status: 'unhealthy', error: error.message }, timestamp: new Date().toISOString() }; } } async collectDatabaseMetrics() { try { const db = new sqlite3.Database(this.databasePath); return new Promise((resolve, reject) => { const queries = [ 'SELECT COUNT(*) as user_count FROM users', 'SELECT COUNT(*) as account_count FROM accounts', 'SELECT COUNT(*) as transaction_count FROM transactions', 'SELECT COUNT(*) as file_count FROM files', 'SELECT COUNT(*) as notification_count FROM notifications' ]; const results = {}; let completed = 0; queries.forEach((query, index) => { db.get(query, (err, row) => { if (err) { this.logger.error(`Database query failed: ${query}`, err); results[`query_${index}`] = { error: err.message }; } else { const key = query.split(' ')[5].replace('_count', ''); results[key] = row[Object.keys(row)[0]]; } completed++; if (completed === queries.length) { db.close(); this.metrics.database = { ...results, timestamp: new Date().toISOString() }; resolve(); } }); }); }); } catch (error) { this.logger.error('Failed to collect database metrics:', error); this.metrics.database = { error: error.message }; } } async collectAPIMetrics() { try { const endpoints = [ '/api/v1/auth/login', '/api/v1/accounts/', '/api/v1/transactions/', '/api/v1/analytics/', '/health' ]; const apiMetrics = { endpoints: {}, totalRequests: 0, averageResponseTime: 0, errorRate: 0, timestamp: new Date().toISOString() }; let totalResponseTime = 0; let errorCount = 0; for (const endpoint of endpoints) { try { const startTime = Date.now(); const response = await axios.get(`${this.backendUrl}${endpoint}`, { timeout: 5000, validateStatus: (status) => status < 500 }); const responseTime = Date.now() - startTime; apiMetrics.endpoints[endpoint] = { status: response.status, responseTime: responseTime, healthy: response.status < 400 }; totalResponseTime += responseTime; apiMetrics.totalRequests++; if (response.status >= 400) { errorCount++; } } catch (error) { apiMetrics.endpoints[endpoint] = { status: 'error', responseTime: null, healthy: false, error: error.message }; errorCount++; apiMetrics.totalRequests++; } } apiMetrics.averageResponseTime = apiMetrics.totalRequests > 0 ? totalResponseTime / apiMetrics.totalRequests : 0; apiMetrics.errorRate = apiMetrics.totalRequests > 0 ? (errorCount / apiMetrics.totalRequests) * 100 : 0; this.metrics.api = apiMetrics; } catch (error) { this.logger.error('Failed to collect API metrics:', error); this.metrics.api = { error: error.message }; } } getMetrics() { return this.metrics; } getSystemMetrics() { return this.metrics.system; } getApplicationMetrics() { return this.metrics.application; } getDatabaseMetrics() { return this.metrics.database; } getAPIMetrics() { return this.metrics.api; } async getMetricsForTimeRange(startTime, endTime) { try { const db = new sqlite3.Database(this.databasePath); return new Promise((resolve, reject) => { const query = ` SELECT DATE(created_at) as date, COUNT(*) as daily_transactions, SUM(CASE WHEN transaction_type = 'credit' THEN amount ELSE 0 END) as daily_income, SUM(CASE WHEN transaction_type = 'debit' THEN amount ELSE 0 END) as daily_expenses FROM transactions WHERE created_at BETWEEN ? AND ? GROUP BY DATE(created_at) ORDER BY date `; db.all(query, [startTime, endTime], (err, rows) => { db.close(); if (err) { reject(err); } else { resolve(rows); } }); }); } catch (error) { this.logger.error('Failed to get metrics for time range:', error); throw error; } } getPerformanceTrends() { const trends = { memoryUsage: this.metrics.system.memory?.used || 0, responseTime: this.metrics.api?.averageResponseTime || 0, errorRate: this.metrics.api?.errorRate || 0, activeUsers: this.metrics.database?.user_count || 0, timestamp: new Date().toISOString() }; return trends; } } module.exports = { MetricsCollector };
