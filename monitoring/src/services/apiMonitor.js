const axios = require('axios'); const moment = require('moment'); class APIMonitor { constructor(logger) { this.logger = logger; this.backendUrl = process.env.BACKEND_URL || 'http: this.frontendUrl = process.env.FRONTEND_URL || 'http: this.monitoringData = { requests: 0, errors: 0, averageResponseTime: 0, lastCheck: null, endpoints: {} }; this.endpoints = [ { path: '/health', method: 'GET', expectedStatus: 200 }, { path: '/api/v1/auth/login', method: 'POST', expectedStatus: 401 },  { path: '/api/v1/accounts/', method: 'GET', expectedStatus: 401 },  { path: '/api/v1/transactions/', method: 'GET', expectedStatus: 401 },  { path: '/api/v1/analytics/', method: 'GET', expectedStatus: 401 },  { path: '/api/v1/monitoring/', method: 'GET', expectedStatus: 401 }  ]; } async getStatus() { try { const startTime = Date.now(); const backendStatus = await this.checkBackendAPI(); const frontendStatus = await this.checkFrontendAPI(); const endpointStatuses = await this.checkEndpoints(); const responseTime = Date.now() - startTime; this.monitoringData.lastCheck = new Date().toISOString(); this.monitoringData.averageResponseTime = this.calculateAverageResponseTime(); return { status: backendStatus.healthy && frontendStatus.healthy ? 'healthy' : 'unhealthy', responseTime: responseTime, backend: backendStatus, frontend: frontendStatus, endpoints: endpointStatuses, monitoring: this.monitoringData, timestamp: new Date().toISOString() }; } catch (error) { this.logger.error('API monitoring failed:', error); this.monitoringData.errors++; return { status: 'unhealthy', error: error.message, timestamp: new Date().toISOString() }; } } async checkBackendAPI() { try { const startTime = Date.now(); const response = await axios.get(`${this.backendUrl}/health`, { timeout: 5000, validateStatus: (status) => status < 500 }); const responseTime = Date.now() - startTime; this.monitoringData.requests++; return { healthy: response.status < 400, statusCode: response.status, responseTime: responseTime, data: response.data, url: this.backendUrl }; } catch (error) { this.monitoringData.errors++; this.logger.error('Backend API check failed:', error.message); return { healthy: false, error: error.message, url: this.backendUrl }; } } async checkFrontendAPI() { try { const startTime = Date.now(); const response = await axios.get(this.frontendUrl, { timeout: 5000, validateStatus: (status) => status < 500 }); const responseTime = Date.now() - startTime; this.monitoringData.requests++; return { healthy: response.status < 400, statusCode: response.status, responseTime: responseTime, url: this.frontendUrl }; } catch (error) { this.monitoringData.errors++; this.logger.error('Frontend API check failed:', error.message); return { healthy: false, error: error.message, url: this.frontendUrl }; } } async checkEndpoints() { const results = {}; for (const endpoint of this.endpoints) { try { const startTime = Date.now(); const response = await axios({ method: endpoint.method, url: `${this.backendUrl}${endpoint.path}`, timeout: 5000, validateStatus: (status) => status < 500, data: endpoint.method === 'POST' ? {} : undefined }); const responseTime = Date.now() - startTime; this.monitoringData.requests++; const isHealthy = response.status === endpoint.expectedStatus; if (!isHealthy) { this.monitoringData.errors++; } results[endpoint.path] = { healthy: isHealthy, statusCode: response.status, expectedStatus: endpoint.expectedStatus, responseTime: responseTime, method: endpoint.method }; if (!this.monitoringData.endpoints[endpoint.path]) { this.monitoringData.endpoints[endpoint.path] = { requests: 0, errors: 0, averageResponseTime: 0, lastCheck: null }; } this.monitoringData.endpoints[endpoint.path].requests++; if (!isHealthy) { this.monitoringData.endpoints[endpoint.path].errors++; } this.monitoringData.endpoints[endpoint.path].lastCheck = new Date().toISOString(); } catch (error) { this.monitoringData.errors++; this.monitoringData.endpoints[endpoint.path] = { requests: 0, errors: 0, averageResponseTime: 0, lastCheck: new Date().toISOString(), error: error.message }; results[endpoint.path] = { healthy: false, error: error.message, method: endpoint.method }; } } return results; } async checkAPIHealth() { try { const status = await this.getStatus(); if (status.status === 'unhealthy') { this.logger.error('API health check failed:', status); return { healthy: false, issues: [status.error || 'API health check failed'], timestamp: new Date().toISOString() }; } const performanceIssues = []; if (status.responseTime > 5000) { performanceIssues.push('High API response time detected'); } const endpointIssues = []; Object.entries(status.endpoints).forEach(([path, endpoint]) => { if (!endpoint.healthy) { endpointIssues.push(`Endpoint ${path} is unhealthy: ${endpoint.error || 'Unknown error'}`); } if (endpoint.responseTime > 2000) { endpointIssues.push(`Endpoint ${path} has slow response time: ${endpoint.responseTime}ms`); } }); const allIssues = [...performanceIssues, ...endpointIssues]; return { healthy: allIssues.length === 0, issues: allIssues, status: status, timestamp: new Date().toISOString() }; } catch (error) { this.logger.error('API health check failed:', error); return { healthy: false, issues: [error.message], timestamp: new Date().toISOString() }; } } calculateAverageResponseTime() { const endpointTimes = Object.values(this.monitoringData.endpoints) .filter(endpoint => endpoint.averageResponseTime > 0) .map(endpoint => endpoint.averageResponseTime); if (endpointTimes.length === 0) return 0; return endpointTimes.reduce((sum, time) => sum + time, 0) / endpointTimes.length; } async testAuthenticatedEndpoint(endpoint, token) { try { const startTime = Date.now(); const response = await axios.get(`${this.backendUrl}${endpoint}`, { headers: { 'Authorization': `Bearer ${token}` }, timeout: 5000 }); const responseTime = Date.now() - startTime; this.monitoringData.requests++; return { healthy: response.status < 400, statusCode: response.status, responseTime: responseTime, data: response.data }; } catch (error) { this.monitoringData.errors++; this.logger.error(`Authenticated endpoint test failed for ${endpoint}:`, error.message); return { healthy: false, error: error.message }; } } async getPerformanceMetrics() { try { const metrics = { totalRequests: this.monitoringData.requests, totalErrors: this.monitoringData.errors, averageResponseTime: this.monitoringData.averageResponseTime, errorRate: this.monitoringData.requests > 0 ? (this.monitoringData.errors / this.monitoringData.requests) * 100 : 0, endpoints: this.monitoringData.endpoints, lastCheck: this.monitoringData.lastCheck }; return metrics; } catch (error) { this.logger.error('Failed to get performance metrics:', error); return this.monitoringData; } } async monitorAPILoad(duration = 60000) { const startTime = Date.now(); const endTime = startTime + duration; const loadData = { requests: 0, errors: 0, responseTimes: [], startTime: new Date().toISOString() }; this.logger.info(`Starting API load monitoring for ${duration}ms`); while (Date.now() < endTime) { try { const start = Date.now(); await axios.get(`${this.backendUrl}/health`, { timeout: 5000 }); const responseTime = Date.now() - start; loadData.requests++; loadData.responseTimes.push(responseTime); } catch (error) { loadData.errors++; this.logger.error('Load test request failed:', error.message); } await new Promise(resolve => setTimeout(resolve, 1000)); } loadData.endTime = new Date().toISOString(); loadData.averageResponseTime = loadData.responseTimes.length > 0 ? loadData.responseTimes.reduce((sum, time) => sum + time, 0) / loadData.responseTimes.length : 0; loadData.errorRate = loadData.requests > 0 ? (loadData.errors / loadData.requests) * 100 : 0; this.logger.info('API load monitoring completed:', loadData); return loadData; } getMonitoringData() { return this.monitoringData; } resetMonitoringData() { this.monitoringData = { requests: 0, errors: 0, averageResponseTime: 0, lastCheck: null, endpoints: {} }; } } module.exports = { APIMonitor };
